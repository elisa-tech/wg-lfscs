# Minimum Linux Requirements for Executing a Minimal Application

# Executive Summary

This investigation, conducted by the Linux Features for Safety-Critical 
Systems (LFSCS) Working Group, aims to identify the minimal Linux kernel 
features required to execute a basic application. 
By tracing kernel interactions during the execution of a simple user-space 
program, we reveal essential dependencies and unexpected function calls within 
the kernel’s core subsystems. This analysis serves as the foundation for 
establishing a baseline Linux configuration, forming the groundwork for 
building safety-critical Linux systems across various applications and 
industries.

# Introduction

This project aims to identify the minimal Linux features required to execute a 
basic application, focusing on the kernel subsystems and functions involved in 
supporting even the simplest user-space program. By tracing the execution of a 
minimal C application, we highlight essential kernel interactions and uncover 
dependencies within the kernel architecture that are foundational to the 
program’s operation. This analysis is critical to understanding which core 
features Linux must provide in baseline configurations for safety-critical 
systems.

At the core of this investigation is a tiny C program `min.c` designed to 
perform a basic operation before entering an infinite loop. By stripping away 
unnecessary code, this program serves as a “bare minimum” application, 
enabling us to capture only the fundamental kernel functions required for 
execution. Using tracing tools, we log the specific kernel calls activated by 
`min.c`, giving a clear view of kernel activity during the program’s runtime. 

A secondary variant, `min.large.c`, explores scenarios where the minimal 
assumptions may not hold, such as requiring a larger text that can trigger 
page faults. Nonetheless, diverging from these assumptions may entail 
different kernel interactions, a point worth highlighting to inform readers of 
the possible implications, but that will likely not be explored in detail in 
this work. 

To better predict the paths and dependencies that might emerge, future 
iterations of this project may incorporate static analysis techniques to map 
expected execution paths in advance, allowing more precise control over the 
tracing process.

The reference architecture for this study is aarch64, with tests conducted 
using QEMU emulation on Buildroot-generated images. These images are tailored 
to reduce kernel and system dependencies, providing a controlled environment 
for examining kernel behavior. Importantly, Buildroot strives to keep 
user-space interaction as minimal as possible. Although the method of starting 
the minimal program as init has not been finalized, it is important to note 
that a complex init sequence, such as the one generated by systemd, is not 
selected. Instead, the init is derived from Buildroot's computation, which 
uses the BusyBox init based on sysV init, with very few init scripts involved. 
Also, because the Linux kernel’s monolithic structure may introduce unexpected 
interactions, we are also working to establish a minimal kernel configuration, 
ensuring that only essential kernel components are active and minimizing 
extraneous calls that could obscure our findings.

This investigation is part of the ELISA project, aiming to provide the working 
group with insights into the baseline Linux configuration needed for safe, 
reliable operation in diverse applications.

**Note:** The current work is focused on assessing the minimal features 
required for a minimal application. To remain minimal, the application does 
not perform any useful operations, including memory allocation. 
While such operations can be complex and influenced by external factors, such 
as actions by other processes, this work intentionally avoids these 
complications.

It’s important to recognize that kernel features exist at different levels. 
For instance, while a page cache mechanism which is by all means a kernel 
feature, it is not necessarily something an application or the main kernel 
paths want to use intentionally. If a kernel path makes use of memory 
allocation within the kernel (e.g., using `kmalloc` or `vmalloc`), it might 
indirectly trigger the use of caching mechanisms, page faults, or the OOM 
killer. However, the feature that the application explicitly requires is not 
the page caching itself, or any other fancy optimization mechanisms, but just 
the ability to allocate memory. While the application may trigger these 
additional mechanisms, the focus of this work is to identify and differentiate 
the essential kernel features that an application directly requires, rather 
than the secondary features it might inadvertently invoke.

The ultimate goal is to establish a clear line in the kernel feature space 
that differentiates what is absolutely necessary for any application to run: 
features that will always be used, and those that are considered optional, 
while recognizing that in some use cases, the so-called optional features may 
be essential for a given application to function properly.

# Objectives and Scope

## **Objective**

The core objective of this investigation is to establish a baseline for a 
"safe Linux" by identifying the essential Linux kernel features required to 
initialize and execute a minimal application. This baseline will form the 
foundation on which safety-critical Linux configurations can be built, 
serving as a trusted starting point for implementing safe Linux systems 
across varied use cases. By analyzing which kernel functions and subsystems 
are invoked during the execution of even a simple user-space program, the 
working group aims to clarify the minimal kernel feature set necessary to 
ensure stable and predictable operation in the most fundamental scenarios.

This baseline is critical to the mission of the working group and the broader 
community, which seeks to create and maintain safe Linux environments suitable 
for a range of safety-focused applications, from embedded systems to regulated 
industries. By defining this minimum feature set, we enable a consistent and 
reliable foundation for building Linux configurations that can be safely 
extended to meet the specific requirements of various use cases.

## **Scope**

The investigation includes the following key areas:

1. **Identification of Essential Kernel Functions and Subsystems**: This study 
   aims to identify the core kernel functions, subsystems, and interactions 
   necessary to execute a minimal application started after system 
   initialization, rather than as the init process. The current architecture 
   uses `ftrace` for instrumentation, which assumes that the instrumentation 
   setup is performed before the application begins. 
   This requires a separate launcher to set up tracing and then execute the 
   instrumented program. While the current approach does not support using the 
   minimal application as init, it may be possible by leveraging boot 
   configurations ([/bootconfig](https://docs.kernel.org/admin-guide/bootconfig.html)) 
   to set up instrumentation before the kernel starts. 
   Achieving this would require modifications to the repository and 
   adjustments to kernel features. These components form the foundation of a 
   baseline Linux configuration that can be extended safely for more complex 
   applications.  
2. **Feature and Dependency Analysis**: By examining kernel interactions 
   invoked during basic program execution, we seek to categorize essential and 
   non-essential kernel features, dependencies, and any unexpected subsystem 
   calls that could impact baseline stability and safety.   
3. **Minimal Configuration Recommendations for Safe Baseline**: Based on the 
   findings, we will provide recommendations for configuring a baseline Linux 
   kernel that includes only the minimal, essential features required for safe 
   operation. Additionally, features that are not supported will be explicitly 
   disabled rather than left to their default values, which can not be reliably 
   to be “OFF”. This baseline configuration is intended to support a wide 
   range of safety-critical environments where optimized and predictable 
   Linux setups are essential.  
* **Flexible Methodology for Evolving Requirements**: While this study 
  currently employs Linux’s ftrace subsystem for tracing and analysis, we may 
  adapt or refine the methodology as needed to ensure thoroughness and 
  accuracy. Alternative methods, such as QEMU-based memory and address 
  tracing, may be integrated to validate and deepen findings. 
  The objective and scope remain stable regardless of the specific tracing 
  technique, ensuring continuity and alignment with the community’s goals.

This investigation does not involve performance optimization or modifications 
to the identified kernel components but is focused strictly on defining the 
minimal safe Linux baseline. 
This baseline will serve as a standard, enabling the safe extension of Linux 
for diverse safety-critical applications across industries and environments.

# Methodology

The methodology for this investigation leverages both `ftrace` and `QEMU` for 
tracing and is broken into specific components:

**Define what a minimal program is**

* **Kernel centric view: describe all the mechanics you know exist and you try to not trigger.**  
* **How to write/create the program**  

## Starting approach

### **1. Primary Components**

* [Reference repository](https://github.com/elisa-tech/wg-lfscs/min_prog_trace)  
* `min.c`**:** A minimalistic C program crafted to highlight kernel-level 
   dependencies without additional overhead. It’s compiled as a statically 
   linked binary with minimal startup files to avoid unnecessary code. For 
   memory management insights, an alternate version, `min.large.c`, has a 
   text body slightly larger than a memory page, thereby triggering kernel 
   memory management (mm) functions.  
* `ftrace_it.c`**:** A wrapper application that configures `ftrace` to trace 
  `min.c`. It runs a sequence of operations to isolate and trace `min.c` 
   effectively:  
    * Spawns a child process to execute `min.c`.  
    * Directs all interrupts to CPU0 and pins the traced process to CPU1, 
      ensuring clear trace data.  
    * Configures `ftrace` settings for targeted function tracing and logs all 
      kernel interactions until the child process completes.

### **2. Data Collection Process**

* **Shared Memory Synchronization:** The parent and child processes use shared 
  memory for synchronization, avoiding extraneous system calls that could 
  interfere with the trace.  
* **ftrace Configuration:** `ftrace` is configured to focus exclusively on 
  kernel functions used by `min.c`, filtering out unnecessary calls and 
  capturing the essential kernel subsystem interactions.  
* **Execution Flow:** Upon launching the script with root privileges (required 
  for `ftrace` access), the sequence records trace data from `min.c` or 
  `min.large.c`, generating logs of kernel calls and dependencies. 
  The trace data, stored in `trace_pipe`, is exported for analysis.

### **3\. Environment and Build Configuration**

* **Buildroot Setup for Minimal Environment:** The test environment, 
  configured for a minimal `aarch64` setup, is generated with Buildroot, 
  incorporating a specific patch `br_package.patch` to include the tracing 
  scripts. Custom configurations for Buildroot `br.config` and the kernel  
  `kernel.config` are applied to reduce the system footprint.  
* **QEMU Emulation:** QEMU runs the aarch64 environment, simulating the 
  minimal Linux environment with basic configurations. Command sequence:
```
qemu-system-aarch64 -M virt -m 512M -cpu cortex-a72 -nographic -smp 2 -kernel output/images/Image
```
* **Tracing within QEMU:** After initializing the virtual machine, `ftrace_it` 
  executes and logs trace data to a predefined output path:
```
mount -t tracefs none /sys/kernel/tracing/
sleep 20 && echo start && cat /sys/kernel/tracing/trace_pipe > /tmp/log &
/usr/bin/ftrace_it /usr/bin/min
```
### **4\. Exploratory Techniques and Alternative Approaches**

* **Alternative Tracing with QEMU:** Another approach under consideration 
  involves using QEMU’s built-in tracing features. By mapping memory addresses 
  accessed during execution, this method could provide lower-level insights 
  into memory use and kernel interactions, particularly if exported process 
  IDs can be integrated with the emulator. While technically complex, this 
  approach may offer a more precise view of minimal function calls, and 
  release the requirement of having tracing functionality builtin the kernel.

### Other possible approaches

* **QEMU as a Debugging Tool**: The proposed method involves using QEMU as a 
  GDB server to add breakpoints in the kernel code. This approach is complex, 
  as GDB typically instruments only a subset of functions. Additionally, 
  unlike within the kernel, the concept of the currently running PID is 
  missing outside QEMU’s local logic, complicating things. 
  However, the PID in the Linux kernel could still be traced via the 
  `task_struct` in `current`, which is stored in the last portion of the stack.

## Interpreting Investigation Data: From ftrace Logs to Actionable Data**

As part of our investigation into the minimal Linux requirements for executing 
a basic application, we traced kernel interactions using `ftrace` while 
running our minimal C program, `min.c`. This log captures the fundamental 
kernel functions involved in executing even the simplest user-space process. 
However, raw ftrace logs can be dense and difficult to interpret. 
To address this challenge, we leverage graph-tool, a utility designed to 
convert these logs into structured diagrams, revealing patterns and 
dependencies within the kernel.
[Here](https://youtu.be/ghUBAndh_uA) a video explaining this section.

### **Transforming ftrace Logs into Graphs**

To make sense of the collected ftrace data, we first transform it into a 
graphical representation. By using graph-tool in conjunction with ks-nav: a 
tool that provides static kernel function call graphs, we generate visual 
mappings of kernel execution paths.

By limiting graph depth, we manage complexity, ensuring the readability of 
results without omitting essential details. For example, a graph of the 
`execve` system call limited to five levels may contain only a small fraction 
of the complete execution path. Expanding this view reveals the intricate 
nature of function calls: while a small graph may show just 369 connections, 
the complete execution flow includes over 9000 edges, underscoring the 
importance of structured analysis.

### **Challenges with ftrace Logs and Kernel Interrupts**

Although ftrace aims to capture kernel interactions initiated by `min.c`, 
external factors introduce noise into the trace. One such complication is 
CPU interrupts. Since interrupts do not have their own process identifiers 
(PIDs), they borrow the PID of the process they interrupt. 
This results in unexpected function calls appearing in the execution graph, 
forming what we term “orphan nodes”: isolated points that do not fit neatly 
into the program’s execution flow.

### **Missing Data and the Role of Non-Traceable Functions**

Tracing kernel execution is not always a complete process. Some functions are 
explicitly marked as non-traceable using the `noinstr` attribute, preventing 
them from appearing in ftrace logs. Additionally, compiler optimizations can 
exclude function calls from tracing, creating gaps in the recorded execution 
path.

To assess these missing traces, we compare the kernel’s symbol table against 
the list of traceable functions:

```
cat /proc/kallsyms | cut -d " " -f3 | sort > all
sudo cat /sys/kernel/tracing/available_filter_functions | cut -d " " -f1 | sort > avail
vimdiff all avail
```

This analysis reveals that numerous functions remain untraceable, 
necessitating alternative methods to infer missing data.

### **Filling the Gaps with Static Analysis**

To compensate for missing function calls in our ftrace log, we leverage 
`ks-nav`’s static analysis capabilities. By overlaying a static function call 
graph onto the dynamically traced execution flow, we can infer missing 
connections. The complete function of `graph-tool` enables us to merge 
these datasets, visually distinguishing inferred connections.

For example, integrating a static graph of `execve` with the ftrace-derived 
graph introduces additional inferred edges:

```
./graph-tool complete -f1 executed.dot -f2 execve.dot -color green | xdot -
```

While this approach improves completeness, it is not foolproof... Some 
indirect calls, such as those involving function pointers, remain unresolved.

### **Dealing with Indirect Calls**

Kernel execution frequently involves indirect function calls, where function 
pointers dynamically determine the next function to execute. 
These calls obscure direct function transitions, complicating execution graph 
reconstruction.

For instance, the function `make_prot` may be identified as part of 
`load_elf_binary`, yet its trace lacks a direct link from its actual caller, 
`bprm_execve`. To resolve this, we query ks-nav’s function call database:

```
ssh dbs "psql -d kernel_bin -c \"select * from symbols where symbol_id in (select caller from xrefs where callee in (select symbol_id from symbols where symbol_name = 'make_prot' and symbol_instance_id_ref=56));\""
```

This enables us to manually integrate missing links by generating a static 
function call graph for `load_elf_binary` and connecting it to our existing 
graph:

```
./graph-tool connect -f1 execve.dot -f2 load_elf_binary.dot -n1 bprm_execve -n2 load_elf_binary > execve_load_elf_binary.dot
./graph-tool complete -f1 executed.dot -f2 execve_load_elf_binary.dot -color green | xdot -
```

Through these steps, we refine our understanding of kernel execution, 
compensating for the limitations of dynamic tracing alone. 
This combined approach allows us to construct a more complete and accurate 
representation of the minimal kernel requirements for executing a basic 
application.

# Findings

**Observation**:  
During a recent working group meeting, a discrepancy was  identified in the 
log of the `min_prog_trace` traced application.  
The function `chacha_block_generic` was observed, which is unexpected given  
its association with the `CRYPTO_API` subsystem.

**Investigation**:  
To understand the root cause of this unexpected occurrence,  a preliminary 
investigation was initiated. The focus of this investigation  was to 
determine how `chacha_block_generic` is being invoked and why it’s appearing 
in the context of the `min_prog_trace` traced application.

**Findings**:  
The log reading suggests that `chacha_block_generic` is invoked  through the 
following call chain:
```
load_elf_binary -> setup_arg_pages -> arch_align_stack -> get_random_u16 -> _get_random_bytes -> crng_make_state -> crng_fast_key_erasure -> chacha_block_generic load_elf_binary -> create_elf_tables (inlined) -> get_random_bytes -> _get_random_bytes ->  chacha_block_generic
```
Reading the source code seem not to confirm this call trace,  in particular, 
the `arch_align_stack` function appear to not call  `get_random_u16`.
```
unsigned long arch_align_stack(unsigned long sp)
{
    if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
        sp -= get_random_u32_below(PAGE_SIZE);
    return sp & ~0xf;
}
```
But it is probably a compiler magic working under the hood, since:
```
┌84: sym.arch_align_stack (int64_t arg1);
│     ; arg int64_t arg1 @ x0
│     ;  var  int64_t var_10h @ sp+0x10
│     0xffffffc080018b20  1f2003d5  nop ; process.c:595  {
│     0xffffffc080018b24  1f2003d5  nop
│     0xffffffc080018b28  3f2303d5  paciasp ; process.c:596  if  (!(current->personality & ADDR_NO_RANDOMIZE)  && randomize_va_space)
│     0xffffffc080018b2c  fd7bbea9  stp  x29, x30,  [sp,  -0x20]!
│     0xffffffc080018b30  fd030091  mov  x29, sp
│     0xffffffc080018b34  f30b00f9  str  x19, [sp,  0x10]
│     0xffffffc080018b38  f30300aa  mov  x19, x0 ; process.c:595  {  ; arg1
│     0xffffffc080018b3c  004138d5  mrs  x0,  sp_el0 ; current.h:19  asm  ("mrs %0, sp_el0"  :  "=r"  (sp_el0));
│     0xffffffc080018b40  008043b9  ldr  w0,  [x0,  0x380]  ; current.h:21  return  (struct task_struct *)sp_el0;  ;  0xda  ;   218
│┌──< 0xffffffc080018b44  e0009037  tbnz w0,  0x12,  0xffffffc080018b60  ; process.c:596  if  (!(current->personality & ADDR_NO_RANDOMIZE)  && randomize_va_space)
││    0xffffffc080018b48  003a00b0  adrp x0,  0xffffffc080759000
││    0xffffffc080018b4c  00f046b9  ldr  w0,  [x0,  0x6f0]  ;  0xda  ;  218
│┌──< 0xffffffc080018b50  80000034  cbz  w0,  0xffffffc080018b60
│││   0xffffffc080018b54  77690894  bl   sym.get_random_u16 ; process.c:597 sp -= get_random_u32_below(PAGE_SIZE);
│││   0xffffffc080018b58  003c44d3  ubfx x0,  x0,  4,  0xc  ; random.h:83  if  (likely(is_power_of_2(ceil)  ||  (u16)mult >=  (1U  <<  16)  % ceil))
│││   0xffffffc080018b5c  730200cb  sub  x19, x19, x0 ; process.c:597 sp -= get_random_u32_below(PAGE_SIZE);
│└└─> 0xffffffc080018b60  60ee7c92  and  x0,  x19,  0xfffffffffffffff0  ; process.c:598  return sp &  ~0xf;
│     0xffffffc080018b64  f30b40f9  ldr  x19, [var_10h]  ;  5
│     0xffffffc080018b68  fd7bc2a8  ldp  x29, x30,  [sp],  0x20  ; process.c:599  }
│     0xffffffc080018b6c  bf2303d5  autiasp
└     0xffffffc080018b70  c0035fd6  ret
```

Binary analysis **confirms** the trace.

**Additional notes**:  
In the `lib/crypto/Makefile` you can read the following:
```
# chacha is used by the /dev/random driver which is always builtin
obj-y                                           += chacha.o

```
And in parent `lib/Makefile`:
```
obj-y += math/ crypto/
```

**Significance**:  
Surprisingly, the `CRYPTO_API`, at least as it pertains to  
the **chacha** functions, appears to be a minimal feature that Linux must  
provide even a very basic level of functionality.  
This suggests that the invocation of `chacha_block_generic` in this context  
is a necessary part of the operating system’s core operations.

#  Conclusion
This investigation has identified the minimal set of Linux kernel subsystems 
required to support a program that performs no operations.
```
AIO
ARM64 PORT (AARCH64 ARCHITECTURE)
CAPABILITIES
CHAR and MISC DRIVERS
CPU HOTPLUG
CRYPTO API
EXEC & BINFMT API
FILESYSTEMS (VFS and infrastructure)
FUTEX SUBSYSTEM
GENERIC INCLUDE/ASM HEADER FILES
LOCKING PRIMITIVES
MEMBARRIER SUPPORT
MEMORY MANAGEMENT
MMU GATHER AND TLB INVALIDATION
PAGE CACHE
PER-CPU MEMORY ALLOCATOR
POSIX CLOCKS and TIMERS
RANDOM NUMBER DRIVER
READ-COPY UPDATE (RCU)
SCHEDULER
SECURITY SUBSYSTEM
SLAB ALLOCATOR
```
By systematically analyzing the execution flow and filtering out extraneous OS 
interferences, we isolated the essential components involved. 
The methodology relied on graph-based representation, where functionalities 
originating solely from the interrupt path were removed to ensure only 
fundamental dependencies remained. The resulting graph (generated using these 
[commands](https://github.com/elisa-tech/wg-lfscs/data/cmds)) highlights these 
core interactions, with a detailed visualization available in the 
[same](https://github.com/elisa-tech/wg-lfscs/data/imgs) project repository.
